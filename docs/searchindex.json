{"categories":[{"title":"找乐子","uri":"https://masterenlu.github.io/blogSite/categories/%E6%89%BE%E4%B9%90%E5%AD%90/"},{"title":"日常","uri":"https://masterenlu.github.io/blogSite/categories/%E6%97%A5%E5%B8%B8/"},{"title":"正经事","uri":"https://masterenlu.github.io/blogSite/categories/%E6%AD%A3%E7%BB%8F%E4%BA%8B/"}],"posts":[{"content":"咕了\n一些吐槽 由于之前上最优化导论没有认真听，导致现在快考试了两眼一摸黑，在加上临近期末的各种事务的堆积，只能挤时间提前开始重新学习这门数学，成为时间管理带师。\n需要了解的部分储备知识 有关向量的线性相关 对于给定的向量组 $A: \\alpha_1, \\alpha_2, \u0026hellip; \\alpha_n$，如果如果存在一组不全为零的实数 $k_1, k_2, \u0026hellip;k_n$，使得 $\\sum\\limits_{i=1}^{n}k_i\\alpha_i = 0$，则认为向量组 $A$ 线性相关，否则为线性无关。\n可以这样判断，对于向量组 $A$，如果存在一个向量 $\\alpha_i$，可以用 $A$ 中 $\\alpha_i$ 以外的有限个向量表示出来，那么这个向量组为线性相关，否则为线性无关。\n$$ if \\quad \\sum\\limits_{i=1}^{n}k_i\\alpha_i=0 \\\nthen \\quad \\alpha_i = -\\frac{1}{k_i}\\sum\\limits_{j=1,j \\ne i}^{n}k_j\\alpha_j $$\n子空间 如果一个空间 $v$ 是 $\\mathbb{R}^n$ 的子空间，那么这个空间对于向量的加法和数乘是封闭的。\n如果有 $\\alpha_1,\\alpha_2,\u0026hellip;\\alpha_n \\in v$，那么有 $span[\\alpha_1, \\alpha_2,\u0026hellip;\\alpha_n]=v$ 。\n如果 $\\forall \\alpha_i \\in v$，$\\alpha_i$ 可用 $v$ 中的一组线性无关的向量表示出来，那么这组线性无关的向量为这个子空间的基，这个子空间的维数 $dim\\ v$ = 基的向量个数。对于一个基，$\\alpha_i \\in v$ 可用这个基唯一地表示出来。\n矩阵 对于一个矩阵，其秩为列向量或行向量的极大无关组中的向量个数。\n对于一个矩阵 $A$，如果进行非零数乘、列交换或者加入可由其中的列向量表示出来的新列向量，矩阵的秩不变。\n行列式 如果一个行列式中有两列或者两行完全一致，那么这个行列式为 0。\n如果一个矩阵的行列式为 0，那么这个矩阵被称为奇异矩阵。\n对于一个线性方程组 $A\\vec{x}=\\vec{b}$，$A$ 被称为系数矩阵，$[A,\\vec{b}]$ 为增广矩阵。\n$$ a_{11} x_1+a_{12} x_2+\\cdots+a_{1n} x_n=b_1 \\\na_{21} x_1+a_{22} x_2+\\cdots+a_{2n} x_n=b_2 \\\n\\vdots \\\na_{m1} x_1+a_{m2} x_2+\\cdots+a_{mn} x_n=b_m \\\nA = [a_1,a_2,\\cdots,a_n],\\vec b = [b_1,b_2,\\cdots,b_m]^T $$\n如果一个线性方程组的增广矩阵和系数矩阵的秩相等，那么这个方程组有解。\n$$ \\begin{aligned} \u0026amp;\\bf{证明：} \\\n\u0026amp;如果 \\quad A\\vec x=\\vec b \\quad 有解 \\\n\u0026amp;那么有 \\quad \\vec b = \\sum\\limits_{i=1}^n A_ix_i \\\n\u0026amp;一定有\\space rank(A)=rank(A,b) \\\n\u0026amp;反之也可证明 \\end{aligned} $$\n如果 $A^{n×n}$ 是非奇异矩阵，那么方程组有唯一解。如果 $rank(A) \u0026lt; n$，那么这个方程组有无穷多个解。\n范数 对于向量 $\\vec x, \\vec y$，$ |\\textbf{x}+\\textbf{y}| \\le |\\textbf{x}| + |\\textbf{y}|$ $$ \\begin{align*} \\bf{证明：} \\\n|\\textbf{x}+\\textbf{y}|^2 \u0026amp;= \u0026lt;\\textbf{x}+\\textbf{y},\\textbf{x}+\\textbf{y}\u0026gt; \\\n\u0026amp;= |\\textbf{x}|^2 + |\\textbf{y}|^2 + 2\u0026lt;\\textbf{x},\\textbf{y}\u0026gt; \\\n\u0026amp;\\leq |\\textbf{x}|^2 + |\\textbf{y}|^2 + 2|\\textbf{x}|\\cdot|\\textbf{y}| \\\n\u0026amp;= (|\\textbf{x}| + |\\textbf{y}|)^2 \\\n\\end{align*} $$\n向量的 P 范数：$|\\textbf{x}|_p = (|\\textbf{x}_1|^p+\\cdots+|\\textbf{x}_n|^p)^\\frac{1}{p}$。当 $p\\rarr \\infin$ 时，$|\\textbf{x}|_p = \\max\\limits_i{|\\textbf{x}_i|}$\n线性变换 如果在空间 $\\mathbb{R}^n$ 和 $\\mathbb{R}^m$ 中的一个函数 $\\mathcal{L}: \\mathbb{R}^n \\rarr \\mathbb{R}^m$\n 对于任意的 $\\textbf{x} \\in \\mathbb{R}^n$ 和 $a \\in \\mathbb{R}$，有 $\\mathcal{L}(a\\textbf{x})=a\\mathcal{L}(\\textbf{x})$ 对于任意 $\\textbf{x}, \\textbf{y} \\in \\mathbb{R}^n$，有 $\\mathcal{L}(\\textbf{x}+\\textbf{y})=\\mathcal{L}(\\textbf{x})+\\mathcal{L}(\\textbf{y})$  那么这个函数可被称为一个线性变换。\n$A=P^{-1}BP$，$B$ 是 $A$ 的相似矩阵。\n线性变换可以用矩阵表示，相似矩阵表示相同的线性变换在不同的基底下的表示\n正交投影 $\\mathcal V$ 是 $\\mathbb{R}^n$ 的子空间，那么 $\\mathcal V$ 的正交补 $\\mathcal V^\\perp = {\\textbf{x}:\\textbf{x}^T \\mathcal v=0, \\forall \\mathcal v \\in \\mathcal V}$，其也是 $\\mathbb{R}^n$ 的子空间。对 $\\mathbb{R}^n$ 上的任意向量 $\\textbf{x}$，都有唯一的 $\\textbf{x} = \\textbf{x}_1+\\textbf{x}_2$，其中 $\\textbf{x}_1 \\in \\mathcal V, \\textbf{x}_2 \\in \\mathcal V^\\perp$\n 需要注意的是，这里的 $\\mathbb R^n = \\mathcal V \\oplus \\mathcal V^\\perp$，即 $\\mathbb R^n$ 由 $\\mathcal V$ 和 $\\mathcal V^\\perp$ 张成，而不能理解为 $\\mathbb R^n = \\mathcal V \\cup \\mathcal V^\\perp$\n $∀x∈R^n$，都有 $Px ∈V$ 且 $x- Px ∈V^⊥$，线性变换 $P$ 称为正交投影算子。$A∈R^{m×n}$\n像空间 $R(A) ≜{Ax:x∈R^n}$，零空间 $N(A)≜{x∈R^n:Ax=0}$，像空间和零空间都是子空间。\n定理：矩阵 $P$ 是子空间 $\\mathcal V = \\mathcal R(P)$ 上的正交投影算子，当且仅当 $P^2 = P = P^\\intercal$ $$ \\begin{aligned} \u0026amp;证明： \\\n\u0026amp;必要性：\\\n\u0026amp;由于 P 是 \\mathcal R(P) 上的正交投影算子，Px \\in \\mathcal R(P)，x-Px \\in \\mathcal R(P)^\\perp=\\mathcal N(P^\\intercal) \\\n\u0026amp;\\forall x, P^\\intercal(I-P)x =0\\\n\u0026amp;即\\space \\forall x, (P^\\intercal-P^\\intercal P)x=0，P^\\intercal=P^\\intercal P \\\n\u0026amp;(P^\\intercal)^\\intercal=P^\\intercal P=P=P^\\intercal=P^2 \\\n\u0026amp;充分性：\\\n\u0026amp;\\forall x,y, (Py)^\\intercal(I-P)x=y^\\intercal P^\\intercal(I-P)x=y^\\intercal(P^\\intercal-P^\\intercal P)x=0\\\n\u0026amp;(I-P)x=0 \\in \\mathcal N(P^\\intercal)=\\mathcal R(P)^\\perp\\\n\u0026amp;证毕 \\end{aligned} $$\n二次型函数 对于一个函数 $\\mathcal f: \\mathbb R^n \\rarr \\mathbb R, \\mathcal f(x) = x^\\intercal Qx$，$Q$ 为对称实矩阵，被称为二次型函数，如果 $\\forall x, x^\\intercal Qx \u0026gt; 0$，则二次型是正定的，$\\ge0$ 为半正定，否则为负定，半负定或不定。\n如果一个二次型是正定的，当且仅当 $Q$ 的每一个顺序主子式是正定的或 $Q$ 的每一个特征值是正数。\n仿射函数 对于一个在 $\\mathbb R^n \\rarr \\mathbb R^m$ 上的线性函数 $\\mathcal L$，如果有 $x \\in \\mathbb R^n, y \\in \\mathbb R^m, \\mathcal A(x) = \\mathcal L(x) + y$，那么这个函数 $\\mathcal A$称为仿射函数。如果一个函数 $\\mathcal f: \\Omega \\rarr \\mathbb R^m$，在 $x_0$ 处存在一个仿射函数能够模拟 $\\mathcal f$，即 $$ \\lim\\limits_{x\\rarr x_0} \\frac{|\\mathcal f(x) - \\mathcal A(x)|}{|x-x_0|}=0\\\n\\mathcal A(x_0)= \\mathcal f(x_0)=\\mathcal L(x_0)+y \\\ny=\\mathcal f(x_0)-\\mathcal L(x_0)\\\n\\mathcal A(x)=\\mathcal L(x) + y =\\mathcal L(x) + \\mathcal f(x_0) - \\mathcal L(x_0) = \\mathcal L(x-x_0) + \\mathcal f(x_0) $$ 那么说在 $x_0$ 上可微。\n","id":0,"section":"posts","summary":"咕了 一些吐槽 由于之前上最优化导论没有认真听，导致现在快考试了两眼一摸黑，在加上临近期末的各种事务的堆积，只能挤时间提前开始重新学习这门数学，","tags":["数学","最优化导论","机器学习"],"title":"最优化简单笔记","uri":"https://masterenlu.github.io/blogSite/2020/06/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/","year":"2020"},{"content":"前言 最近在准备最优化的考试，需要反复看钉钉上的直播录像，但是钉钉自带的播放器功能实在太拉胯了，老师又不给开放下载权限，只能采取这种抓包的方式来下载。\n准备工具 Fiddler Fiddler 是一款常用的抓包工具：官网\n安装 Fiddler 之后，需要在 Tool/Options/HTTPS 中勾选 Capture HTTPS CONNECTs、Decrypt HTTPS traffic 和 Ignore server certificate errors (unsafe) 三个选项，中间会弹出窗口安装证书，同意就行。\n点击 Find 搜索 .m3u8 右键选取高亮条目，选择 Copy 下的 Just Url 复制流媒体源。\n 需要注意的是，在第一次查找过后，如果还需进行下一个流媒体的查找，需要点击 Replay 和 Go 中间的选项选择 Remove all 来清楚记录，否则查找到的还会是第一次查找的内容。\n N_m3u8DL-CLI N_m3u8DL-CLI 是开源在 Github 上的一款 m3u8 下载器：开源地址\n压缩包中包含两个可运行文件： N_m3u3DL-CLI_version.exe 和 N-m3u8DL-CLI-SimpleG.exe\n其中第一个是下载需要的主要程序，第二个是一个图形化的配置界面。\n如果图一个省事，直接在第一个程序中粘贴已经抓到的流媒体源就可以下载，默认下载地址是程序目录下的 Downloads 文件夹中。\n如果需要进行细化的配置，可以在第一个程序中使用命令行选项或者直接在第二个程序中进行。\n在第二个程序中将流地址粘贴在 M3U8地址 一项中点击 GO(S) 就可以开始下载到指定的文件夹中。\n默认的下载格式应该是 mp4 文件。\n","id":1,"section":"posts","summary":"前言 最近在准备最优化的考试，需要反复看钉钉上的直播录像，但是钉钉自带的播放器功能实在太拉胯了，老师又不给开放下载权限，只能采取这种抓包的方式","tags":["Fiddler","m3u8","钉钉","抓包"],"title":"Fiddler + N_m3u8DL-CLI 下载钉钉直播录像","uri":"https://masterenlu.github.io/blogSite/2020/06/fiddler-n_m3u8dl-cli-%E4%B8%8B%E8%BD%BD%E9%92%89%E9%92%89%E7%9B%B4%E6%92%AD%E5%BD%95%E5%83%8F/","year":"2020"},{"content":"写在前面 2020年5月6日，最后一节人工智能课上，老师宣布将期末考试改成大作业的形式（其实之前就说过，但是具体是哪天我忘了），要求使用 cnn 网络和 pytorch 框架完成布置的几项任务之一。\n直到这一天，我们才真正了解人工智能导论的真正含义，不是入门，而是自己动手写实际项目。没办法，零基础的我只能选择一个最简单的图片分类来做一做，这篇文章也是记录一下，如果以后有需要的话还可以参考一下。\n现在可以在 Github 上找到这个工程\n关于 CNN 首先要做的就是了解需要用到的框架和网络。\n要求使用 cnn 网络来完成任务，但是之前上课只讲过神经元网络（nn）,所以这里顺手就打开了一个维基百科\n 卷积神经网络（Convolutional Neural Network, CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，[1]对于大型图像处理有出色表现。\n卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和池化层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和语音识别方面能够给出更好的结果。这一模型也可以使用反向传播算法进行训练。相比较其他深度、前馈神经网络，卷积神经网络需要考量的参数更少，使之成为一种颇具吸引力的深度学习结构[2]。\n 简单来说就是一个使用卷积运算来处理数据的神经网络。包括卷积层、池化层和全连接层。\n在每个卷积层上都会有一个或多个卷积核（$kernel$）来对二维化的数据进行扫描和卷积运算。在池化层上会对卷积后的数据进行压缩。最后就是普通神经元网络的全连接层。\n在卷积操作时，卷积核会对 $kernel_size$ 内的数据每 $stride$ 一次进行卷积运算。但是这样每次运算图片都会变小，为了避免这种情况，引入了 $padding$，即在原数据周围加上 $padding$ 层的 $0$ 数据。\n网上关于 CNN 的介绍有很多，这里不再废话，有条件的可以看看什么是卷积神经网络 CNN (Convolutional Neural Network)\n数据集准备 这里国内交通标识分类数据集比较少，我这里在 Chinese Traffic Sign Database 上找到了一个数据集，可惜的是数据集比较小，供训练的图片只有 4k+ 张，而且分布不均匀，58 个分类，有些分类只有几十张训练图。只能后期进行数据增强了。\n下载下来数据集和标记文件，为了方便，我将标记文件的格式改成了\npath/fileName class  的格式。\n从 torch.utils.data 导入 Dataset，根据官方文档，可以自定义的数据集有两种，map-style datasets 和 iterable-style datasets，这里选择了第一种，然后创建继承自 Dataset 的数据集类，创建的数据集应该包括三个方法：\nclass trafficDataset(Dataset): def __init__(self, label_file_path, train=True): def __getitem__(self, index): def __len__(self):  在初始化方法中，需要读取图片和其分类，只需读取标识文件中的图片路径和分类即可\ndef __init__(self, label_file_path, train=True): f = open(label_file_path, 'r') self.data = list(map(lambda line: line.strip().split(' '), f)) # 读取文件和分类 self.train = train # 标记是否用于训练  在 __getitem__ 方法中，需要根据给的下标来读取选择的数据，这里由于之前载入的 data 是图片路径和分类，所以 path, label = self.data[index]，然后根据是否用于训练对图像分别处理。这里的图片处理和数据增强需要用到 torchvision 中的 transforms 和 PIL 中的 Image。\nif self.train: # 训练集执行数据增强 img = transforms.Compose([transforms.Resize((256, 256)), # 统一尺寸 transforms.RandomRotation([-30, 30]), # 在-30度到30度之间随机旋转 transforms.RandomGrayscale(0.3), # 以0.3的概率将图片转为灰度 transforms.ColorJitter(brightness=0.5, contrast=0.5), # 随机改变图片的亮度饱和度 transforms.ToTensor(), # 将图片转为 Tensor 格式 transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)) # 图片归一化 ])(Image.open(path).convert('RGB')) else: # 测试集不执行 img = transforms.Compose([transforms.Resize((256, 256)), transforms.ToTensor(), transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)) ])(Image.open(path).convert('RGB'))  然后将获得的 img 和 lable 作为返回值。\n__len__ 方法为获取数据集长度。\n使用 pytorch 构建自己的 CNN 网络 构建数据集之后就是关键的 CNN 网络的构建，由于同样是图形分类，这里网络的构建可以参考网上一些经典的 CNN 网络，比如 LeNet-5 网络。\n要构建神经元网络，首先导入 torch 中的 nn，然后继承 nn.Module 构建自己的神经元网络类，应该包含两个方法\nclass cnn(nn.Module): def __init__(self): # 初始化 super(cnn, self).__init__() def forward(self, x): # 正向传播  按照上面说的三个层次，在初始化方法中依次添加卷积层、池化层和全连接层。LeNet-5 网络除了这三个之外还包括一个激活层。\nclass cnn(nn.Module): def __init__(self): super(cnn, self).__init__() self.conv1 = nn.Conv2d(in_channels=3, # 卷积层 out_channels=16, kernel_size=5, stride=1, padding=2) self.relu = nn.ReLU(inplace=True) # 激活层 self.maxpool = nn.MaxPool2d(kernel_size=2) # 池化层 self.fc = nn.Liner(16*128*128, 58) # 全连接层 def forward(self, x): x = self.conv1(x) x = self.relu(x) x = self.maxpool(x) x = x.reshape(x.size(0), -1) x = self.fc(x) return x  一个简单的 LeNet-5 网络就搭建完成了。在这个网络里只进行了一次卷积，实际上需要用到的卷积层可能更多，可以根据不同需求来添加。\n同时为避免过拟合通常也会添加 dropout 等，需要注意的是 BN 和 dropout 一般不并用，似乎是会导致方差偏移。\n有关于卷积层的输入和输出尺寸问题，这里有一个公式，假设一些变量 $H_i, W_i, D_i, H_o, W_o, D_o$ 分别为输入时的长宽深和输出时的长宽深，$C_i, C_o, K, S, P$ 分别为卷积层的五个参数。\n有： $$ \\begin{split} H_o \u0026amp;= \\left\\lfloor\\frac{H_i-K+2P}{S}\\right\\rfloor+1 \\\\\nW_o \u0026amp;= \\left\\lfloor\\frac{W_i-K+2P}{S}\\right\\rfloor+1 \\\\\nD_o \u0026amp;= \\left\\lfloor\\frac{D_i-K+2P}{S}\\right\\rfloor+1 \\end{split} $$ 池化层使用同一个公式。\n训练部分 在数据集和神经网络都搭建完成之后，就可以开始训练自己的模型了。\n开始之前需要创建数据集对象\nfull_data = trafficDataset(label_file_path='./Train/label_train.txt', train=True) # 指定训练集和验证集的数据 train_size = int(0.9 * len(full_data)) vali_size = len(full_data) - train_size # 将训练集的一部分拿出来用做验证 train_data, vali_data = torch.utils.data.random_split(full_data, [train_size, vali_size]) train_loader = DataLoader(train_data, batch_size=16, shuffle=True) # 每16个一批进行训练，顺序随机 vali_loader = DataLoader(vali_data, batch_size=16, shuffle=True)   如果需要使用 GPU 进行训练，需要指定模型对象和数据使用的设备\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu') model = cnn().to(device)   然后指定用于后向传播的 loss 方法、优化器、学习率和 epoch 等数据。\nEPOCH = 50 LEARNING_RATE = 0.001 # 学习率 loss_func = nn.CrossEntropyLoss() # 交叉熵 optimizer = torch.optim.AdamW(model.parameters(), lr=LEARNING_RATE, amsgrad=False, weight_decay=0.0005)   如果需要按 epoch 设置动态学习率，可以使用 torch.optim.lr_scheduler 中的方法来设置衰减率，然后在每个 epoch 结束后进行 scheduler.step() 来改变学习率。\n⚠ scheduler 是 torch.optim.lr_scheduler.bulabula 的对象\n 然后就可以开始训练了\nfor epoch in range(EPOCH): torch.cuda.empty_cache() for step, (images, labels) in enumerate(train_loader): images = images.to(device) # 将数据送到指定设备 labels = labels.to(device) outputs = model(images) # 获取预测值 loss = loss_func(outputs, labels) # 获取交叉熵 optimizer.zero_grad() # 梯度归零 loss.backward() # 反向传播 optimizer.step() # 梯度更新 # 每20次训练输出一次 if step % 20 == 0: print('Epoch [{}/{}], Step [{}/{}], Loss: {:.7f}'.format(epoch + 1, EPOCH, step + 1, total_step, loss.item()))  可以使用类似测试的方法可以在每个 epoch 后对验证集进行一次验证。\n训练结束之后可以使用 torch.save(model.state_dict(), 'model.pt') 来将训练好的模型保存到本地，以便测试。\n测试部分 如果有保存的模型，先使用创建一个模型对象，并且使用 model.load_state_dict(torch.load('model.pt')) 来加载之前保存的模型。\n需要注意的是，在正式开始测试之前，要使用 model.eval() 先将模型对象的模式改成评估。\nfor images, labels in test_loader: images, labels = images.to(device), labels.to(device) with torch.no_grad(): outputs = model(images) # 获取预测 maxk = max((1, 5)) labels_resize = labels.view(-1, 1) _, predicted = outputs.topk(maxk, 1, True, True) # 获取可能性最大的5个类别 correct += torch.eq(predicted, labels_resize).sum().item() total += labels.size(0)  这里采用 top-5 的预测方式来预测类别。\n第一个模型 第一个模型用了4个卷积层、激活层、池化层和一个全连接层，没有数据增强。在学习率 0.01 的情况下使用 Adam 优化器跑了 50 个 epoch，结果并不理想，大概只有50左右的正确率。\n在后面对训练集进行数据增强后，正确率提高到 80 以上，但是似乎 f1 分数不高，这可把我这个没经验的👶👶急坏了。\n于是，在多方咨询和舍友建议下，我将我的 CNN 网络改为了 ResNet。\n什么是 ResNet 深度残差网络（Deep residual network, ResNet）是由何凯明团队在2015年提出的一种卷积神经网络。其使用残差学习的方式来解决深层网络退化的问题。\n将输入 $x$ 的特征记为 $H(x)$，那么对于这个 $x$， 残差为 $F(x)=H(x)-x$，那么这个特征就是 $H(x)=F(x)+x$。\nResNet 参考并修改了 VGG19 的网络结构，加入了残差单元。\n具体在论文里可以看 （懒得写了。\nResNet 网络的搭建 pytorch 官方实现 在 pytorch 官方库里有 ResNet 的实现代码，我们可以参照一下，源码在 Github 上可以找到。\n自定义搭建 这里主要是在官方的代码上稍微改了一下，由于只用到了 resnet50，所以残差块就只设置了一个，参数也取消掉了。\n残差块：\nclass BasicBlock(nn.Module): def __init__(self, in_num, num, stride): super(BasicBlock, self).__init__() self.stride = stride self.conv1 = nn.Sequential( nn.Conv2d(in_num, num, kernel_size=1, bias=False), nn.BatchNorm2d(num), nn.ReLU(inplace=True) ) self.conv2 = nn.Sequential( nn.Conv2d(num, num, kernel_size=3, stride=self.stride, padding=1, bias=False), nn.BatchNorm2d(num), nn.ReLU(inplace=True) ) self.conv3 = nn.Sequential( nn.Conv2d(num, num * 4, kernel_size=1, bias=False), nn.BatchNorm2d(num * 4) ) self.conv4 = nn.Sequential() if in_num != num * 4 or stride != 1: self.conv4 = nn.Sequential( nn.Conv2d(in_num, num * 4, kernel_size=1, stride=self.stride, bias=False), nn.BatchNorm2d(num * 4) ) def forward(self, x): y = self.conv1(x) y = self.conv2(y) y = self.conv3(y) residual = self.conv4(x) return nn.ReLU(inplace=True)(residual + y)  第二个模型 在改为 ResNet 网络之后，0.001 学习率用 adamw 跑了 15 个epoch，结果如图\n测试集准确率可以到92，但是这个 loss 波动有点夸张，于是我将学习率改成 0.01，跑了 50 个 epoch，结果如图\n实际上这个是手滑了，本来想用 SGD 的，结果学习率啥的改了，优化器没改。\n感觉还是可以的，至少作为我第一个 AI 模型来说，应该算是比较成功了。\n作图 本来是不想画图的，但是要看一个参数的走向，所以就学习了一下。\n多子图 由于要作几个分数和 loss 的变化曲线，一个曲线图看起来可能会很挤，而且几个分数的值都差不多，会重叠，所以就做成了多子图的形式。\n首先定义一下 figure 的尺寸和 dpi：plt.figure(figsize=(10, 10), dpi=100)\n然后这里定义一下网格分布：grid = plt.GridSpec(3, 2, wspace=0.2, hspace=0.5)，总共是三行两列。\n使用 subplot() 可以创建子图，在创建的同时指定子图的布局就行了，比如：plt.subplot(grid[0, 0]) 就是在第一行第一列的地方新建一个子图。如果需要跨多个网格，可以使用 start:len 的格式，比如 plt.subplot(grid[2, 0:2]) 就是在第 3 行第 1 到 2 列的地方新建一个子图。\n这里需要注意一下，如果要定义子图的名称，需要使用的方法是 title() 而不是 subtitle()。\n使用 plot(x,y) 指令就可以作图了。\n之后使用 show() 指令就可以显示图表，需要注意的是，如果在子图定义完成之前就使用 show()，可能会打乱设定的格式。\n横向柱状图 想做一下预测一张图片的时候显示的结果，按照预想的，结果图分为两个部分，左边第一部分是原图片，右边则是从小到大排列的可能的结果。\n这个可以通过上面的多子图来实现，不多说。\n主要是这个横向柱状图。其实就是把 x，y 轴颠倒了一下。\n直接使用 barh(x,y,align='center') 来作图，这里的 x 代表纵轴，y 代表横轴，align 表示下表是否居中。使用 axis('off') 可以关闭图像的坐标，可以在作原图像子图时用到。\n这里由于 x 全是数字，需要转换成对应的类名，可以使用 yticks(index, label) 来改变纵轴上数值的名称，将 index 改为 label。\n完成的效果： 结尾 真正的从零开始做一个东西，总共算下来大概花了两个周末来完成这个模型，期间狂听 Aimer，已经沉迷于这个甜美的旅人。\n从的来说感觉还是挺不错的，好歹学到了一些东西 （指狂听 Aimer，比在家闲着摸鱼强。\n","id":2,"section":"posts","summary":"写在前面 2020年5月6日，最后一节人工智能课上，老师宣布将期末考试改成大作业的形式（其实之前就说过，但是具体是哪天我忘了），要求使用 cnn 网络","tags":["CNN","ResNet","图像分类","PyTorch","卷积神经网络"],"title":"从零开始完成人工智能大作业","uri":"https://masterenlu.github.io/blogSite/2020/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%8C%E6%88%90%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E4%BD%9C%E4%B8%9A/","year":"2020"},{"content":"之前为了图个方便，把课程表导入到了 outlook 里面，于是把 outlook 桌面端给安装了。\n然后就在前两天，突然发现 win10 自带的日历中有两个 outlook 邮箱，于是我把其中一个给删了，今天登录 outlook 改课程表的时候突然弹出来一个窗口，说是我 outlook 邮箱的凭证过期了，让我重新登录，当我输入完密码之后这个窗口再次弹了出来，看起来应该是失败了，这个问题之前我也遇到过，后来靠着一系列神奇的操作把它解决了，然后这次由于我忘了上次是咋整的了，就自己开始琢磨。\n看窗口的样式是 win10 的用户验证窗口，我就想是不是桌面的登录密码，试过之后发现不对。然后我一看这个用户名显然不是我设置的用户名，灵机一动，把用户名给补全，自信满满重新试一次，果然还是失败了。然后后来我疯狂尝试我的巨硬密码+默认名称，巨硬密码+补全名称等都没有成功。\n就在我想不能上拉倒，我去网页上改的时候，随手试了一下 outlook 邮箱地址+密码，居然 tm 就过了？\n 需要注意的是，如果帐号开启了二次验证，需要输入应用密码\n 这事最坑的地方不是说没给提示，而是弹出了一个 win10 桌面登录风格的验证器，而且在用户名输入框给了一个误导的本地用户名。\n就这事在好多地方都把我坑的不行，所以就记一下这个坑，以免我后面再忘了。\n","id":3,"section":"posts","summary":"之前为了图个方便，把课程表导入到了 outlook 里面，于是把 outlook 桌面端给安装了。 然后就在前两天，突然发现 win10 自带的日历中有两个 outlook 邮箱，于是我把其中一个给删了","tags":["outlook","邮箱"],"title":"记录一件比较坑的事","uri":"https://masterenlu.github.io/blogSite/2020/05/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BB%B6%E6%AF%94%E8%BE%83%E5%9D%91%E7%9A%84%E4%BA%8B/","year":"2020"},{"content":"前言 由于电脑里的命令行有丶多其实就三个，就想着有没有一个工具能够集合一下，正好巨硬的 Windows Terminal 现在正在预览阶段，所以就直接用上了。\n~其实就是闲着没事干，找点乐子~\n关于Windows Terminal Windows Terminal是微软官方开发并开源一个终端应用\n开源地址：https://github.com/microsoft/terminal\n Windows Terminal is a new, modern, feature-rich, productive terminal application for command-line users. It includes many of the features most frequently requested by the Windows command-line community including support for tabs, rich text, globalization, configurability, theming \u0026amp; styling, and more. The Terminal will also need to meet our goals and measures to ensure it remains fast and efficient, and doesn\u0026rsquo;t consume vast amounts of memory or power.\n 简单来说就是一个更现代的多功能命令行工具，包含多种命令行功能，同时支持选项卡、主题等个性化配置。\nWindows Terminal的安装 官方给了三种安装方式\n  使用 Microsoft Store 搜索 Windows Terminal 并安装，这种方法可以及时获取最新版本的 Windows Terminal，这也是巨硬推荐的一种安装方式\n ⚠ 注意：这种方法需要你的 Windows 系统在 Win10 1903 (build 18362) 以上才能使用\n   通过 Github 安装，前面说过 Windows Terminal 是一个开源工具，在 Github 上可以找到开源仓库。 如果无法在 MS 商店里安装，可以在开源仓库的 Releases page 下载并手动安装。\n ⚠ 注意：使用这种方式需要确保已经安装 C++ Runtime v14 framework package for Desktop Bridge\n   通过 Chocolatey 工具安装\nchoco install microsoft-windows-terminal  以安装WT\nchoco upgrade microsoft-windows-terminal  以更新WT\n  当然还可以下载源码，自己编译，不过有一说一，能自己编译安装的也不会看这个 滑稽叹气.jpg\n简单配置 安装完成之后打开WT，可以看到主界面\nWOW, amazing\n点击 ➕ 可以打开新的页面，或者可以选择 ⌵ 选择打开其他类型终端。这里点击 ⌵ 可以看到有一个 Settings 选项，这个就是WT的用户配置选项，可以使用 Ctrl + , 快捷键来快速打开。另外可以使用 Alt + 点击 Settings 来打开默认的配置文件 default.json，一般来说 default.json 文件是不可以更改的，需要更改的话可以参照 default.json 里的选项来在 profiles.json 配置。\n在 profiles.json 文件的 profiles: list: 就是WT可以打开的 shell 或命令行 guid 用来标识要打开的 shell 或命令行，可以在 powershell 里使用 [Guid]::NewGuid() 命令来生成新的 guid name 是shell或命令行的名称，可以随便取 commandline 是要执行的命令 hidden 项可以选择关闭某个选项，默认为 false\n再回到头部，可以看到一个 defaultProfile，这一项就是选择打开 WT 时的默认窗口，通过选择相应窗口的 guid 来更改。\n在 profiles: defaults: 里可以更改一些默认属性，比如\n\u0026quot;fontFace\u0026quot;: \u0026quot;字体\u0026quot; \u0026quot;cursorShape\u0026quot;: \u0026quot;光标类型\u0026quot; \u0026quot;useAcrylic\u0026quot;: true/false //使用亚克力背景 \u0026quot;acrylicOpacity\u0026quot;: //透明度 \u0026quot;startingDirectory\u0026quot;: \u0026quot;.\u0026quot; //默认打开路径  除此之外还可以在 schemes 里设置主题，在 keybindings 里设置快捷键绑定，具体可以参照官方文档\n增加git-bash窗口 由于 cmd 和 powershell 已经自带，我要做的只有增加一个 git-bash 窗口😏️\n按照上面的，只需要在 profiles: list: 增加一个新的选项，使用 powershell 生成一个新的 guid，并且在 commandline 选项填上 git-bash 的路径，如果想要添加图标的话，可以在下面新增一个 icon 选项并选择图片\n完成之后保存文件就可以实时更新。\n更改注册表实现右键WT菜单 官方并没有给出一个教程\n Add a \u0026ldquo;Open Windows Terminal Here\u0026rdquo; to File Explorer Not currently supported \u0026ldquo;out of the box\u0026rdquo;. See issue #1060\n 但是我们可以通过更改注册表来实现这个右键菜单功能\n 2020 5 6 现在可以在 Github 上看一看 kerol2r20 大佬的 Windows-terminal-context-menu 项目\n 用户模式 首先打开注册表编辑器，找到路径 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell，新建一个 wt 项，更改默认值数据为 Windows Terminal here 或者其他想在右键菜单里显示的内容，然后新建一个 command 项，将其默认值数据更改为 C:\\Users\\your_username\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe\n ⚠ 注意：使用debug版本编译出来的应用程序是 wtd.exe\n 这个时候右键菜单里就出现了 Windows Terminal here 选项，如果想要按住 shift 点击右键出现的话需要在 wt 里新建一个字符串值，将其命名为 Extended。如果想要在选项旁边增加一个图标，需要在 wt 里新建一个可扩充字符串值 Icon ，将数据为 你想要的图标的路径\n管理员模式选项 还是在 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell，新建一个 runas 项，更改默认值数据为 Windows Terminal here（管理员） 或者其他想显示的内容，其余操作跟普通用户一样。\n使用 Windows Terminal here（管理员） 选项打开的 WT 将会获得管理员权限。\n打开路径 如果发现点击 Windows Terminal here 之后终端的路径依然是用户路径，就需要更改配置文件\n上面提到过 startingDirectory 这个配置项，这个就是打开的路径\n我们将其配置成\n\u0026quot;startingDirectory\u0026quot;: \u0026quot;.\u0026quot;  保存即时生效。\n新的思路 在新的官方文档中出现了这样一项\n Open Windows Terminal in the current directory wt -d .  This will launch a new Windows Terminal window in the current working directory. It will use your default profile, but instead of using the startingDirectory property from that it will use the current path. This is especially useful for launching the Windows Terminal in a directory you currently have open in an explorer.exe window.\n 简单来说就是可以使用 wt 的命令行来实现打开 terminal 并且使用当前路径，我们可以在上面更改的注册表的 command 的默认值的数据更改为 C:\\Users\\your_username\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe -d . 来实现这个功能。\n而且按照官方文档的说法来看，-d 命令的优先权是大于 startingDirectory 的，可能是因为在启动的时候先按照配置文件运行程序，再执行命令的原因。也许可以通过这一点来找点乐子。\n隐藏 powershell here 或 cmd here 在拥有了 Windows Terminal here 之后，powershell here 或 cmd here 就显得很多余，可以通过一些方法来去掉，依然是通过更改注册表。\n依然是在 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 路径中，更改 cmd 或 Powershell 的 ShowBasedOnVelocityId 值，将其重命名为 HideBasedOnVelocityId\n如果重命名失败，说明权限不够，需要更改为管理员用户或者提升用户管理员权限，具体不再多说。\n后记 这篇文章其实早该写的，最早在19年就使用过 Windows Terminal 这个工具，不过后来重装系统之后就没下回来。\n直到今年清明节，因为禁娱的原因，难得的能够闲下来，就想着找些事情做，然后就在论坛上（也许）看到了有过 WT 的帖子。安装配置花了一上午，还没来得及写些东西其实是根本没想写，就被高中同学叫出去踏青。回来之后也没再管过。\n正好前两天把博客重新搭了起来，就想着有空把这个坑给填上，今天终于在水课期间把这篇文章写完，算是拔了一个 flag。\n","id":4,"section":"posts","summary":"前言 由于电脑里的命令行有丶多其实就三个，就想着有没有一个工具能够集合一下，正好巨硬的 Windows Terminal 现在正在预览阶段，所以就直接用上了。 ~其实就是闲着没","tags":["Windows-Terminal","注册表","Windows","terminal"],"title":"Windows Terminal的简单配置","uri":"https://masterenlu.github.io/blogSite/2020/04/windows-terminal%E7%9A%84%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/","year":"2020"},{"content":"写在前面  注意！这篇文章并不是一个教程，只是把我在搭建博客的过程和中间遇到的问题记录一下。\n 其实之前也搭过一个静态博客，搭了两次，使用hexo框架。本来是想在博客上写点题解，记录一下自己在刷题和学习过程中遇到的坑和一些生活上面的感想，于是有了Hello-World-again这篇文章并不算。后来18年寒假进了技术部之后没了压力和方向，在加上本身懒到一种极致没有课绝对不会出宿舍门，刷题啥的也就慢慢落了下来，后来一直到现在没写过一道题，在原来博客里更新的几篇题解也全都转到了CSDN上，之后就没再管过博客的事情。\n直到昨天，想用github上的一个项目开发一个东西，想了想用qt写了个图形界面，然后在实现功能过程中疯狂吃瘪，甚至一些之前踩过的坑都全忘了，又踩了一遍。于是我痛定思痛，决定以后及时更新博客，把自己踩过的坑全记下来防止再踩一遍。\n于是我想起了被遗忘的博客，然后测试了一下还能不能用，然后就有了下面的情况\n进博客看了看自己仅有的两篇博shui客wen，决定从头开始搭一个新的博客，顺便把这篇作为新博客的开端，这才有了现在这篇文章。\n关于hugo 为什么不再使用hexo作为新博客的框架了呢？一是因为hugo使用的go语言以后可能会学，现在整一下环境完事。第二个就是感觉我跟hexo水土不服（并不），这次换一个试试。\nhugo与go的安装 hugo按照官方文档走就可以。\n这里我看到最后才发现可以不下载chocolatey工具，直接下载hugo开源的发布版，解压缩后把添加hugo/bin到path环境变量就行了。\ngo的安装直接按照官方文档走，下载一个安装包一步到位。\n安装完成之后如果要验证的话需要重启命令行，使用 hugo help 验证hugo的安装，go 来验证go的安装\n选择主题并生成网页 然后创建要部署博客的文件夹，hugo new site floderName 就可以看到新部署的文件夹。\n然后在官网上选择一个主题下载下来，解压缩到 theme 文件夹内，然后把目录里的配置文件复制到博客根目录。\n这里主题配置文件可以是 toml、yaml 和 yml 三种格式\n如果是 toml 格式可以直接复制内容到根目录的 config.toml 文件中，否则需要复制原配置文件里的内容到主题的配置文件，然后把原配置文件删除。注意配置内容格式，我选择的主题使用的是 yml 文件。\n在新文件夹内执行 hugo new posts/bulabula.md 就可以在文件夹内的 content/posts 里看见生成的md文件。\n执行 hugo -D来部署静态网页，之后 hugo server可以打开本地服务器预览效果。\n利用github仓库和github pages 首先需要在github上新建一个没有 readme 和 lisence 的空仓库，把博客的文件夹初始化并 push 到仓库中\n这个时候按照官方文档来走，官方给了三个选择：\n Deployment of Project Pages from /docs folder on master branch\nDeployment of Project Pages From Your gh-pages branch\nDeployment of Project Pages from Your master Branch\n 第一个将在 master 分支下的 /docs 子文件夹部署网站，第二个是新建 gh-pages 分支来部署网站，第三个就是使用新仓库来部署网站。\n第二种和第三种比较接近，当提交更改时需要提交两次，相比之下第一种只需要提交一次就可以。这里按照顺序选择了第一种方法并不是懒。\n第一种方法需要更改 hugo 渲染网页的目录，默认是 public 目录，需要我们手动将 config 中的发布目录更改成 docs\npublishDir: docs\r  如果是 toml 文件格式为  publishDir = \u0026quot;docs\u0026quot;\r 更改完文件之后重新在本地部署一次，确认有 docs 目录了之后直接一波git三连\n$ git add .\r$ git commit -m \u0026quot;\u0026quot;\r$ git push -u origin master\r 完了之后打开仓库中的 Settings 往下找到 Github Pages，把 Source 一项改成 master branch /docs floder\n那么 public 文件夹实际上就不再需要了，为了避免麻烦，直接在 .gitignore 里加上 \\public 以在 push 的时候不再更新 public 文件夹。\n接下来要等一段时间。\n今天就先到这，溜了，都11丶了，该摸了。\n一个玄学问题 按理说按照之前的步骤建好github pages之后直接访问域名就可以看到网站了，今天早上打开之后发现是这个样子的\n然后在我一顿操作之后突然就好了，至今不清楚到底是因为啥。\n关于图片插入的坑 在写这篇文章的时候，插入了几个图片。由于我不想使用图床，直接把要插入的图片放在 static 文件夹里，然后按照官方文档给的格式使用相对路径插入图片。\n By default, the static/ directory in the site project is used for all static files (e.g. stylesheets, JavaScript, images). The static files are served on the site root path (eg. if you have the file static/image.png you can access it using http://{server-url}/image.png, to include it in a document you can use ![Example image](/image.png) ).\n 那么问题来了，使用这种相对路径插入的时候本地是识别不出来的，md文件在 content\\posts 文件夹，图片在 static 文件夹，所以在本地查看的时候需要按照完整的相对路径查看，但是在发布到page上时又要更改过来，很麻烦。\n而且使用官方的相对路径，要求发布的网页必须在 public 文件夹里，docs 文件夹不生效，原因未知。\n最后还是选择了图床的模式其实是懒得看官方文档了，把仓库当作图床，采用 url = baseURL/img/image 的模式。\n主题的问题 上面提到过需要更改根目录下的配置文件，但是在配置文件内引用的资源文件没有被更改。需要进入主题文件夹内的 static 和 assets 文件夹内更改资源文件为自己想要的，比如更改头像。\n目录 在配置文件中配置\nconfig:\rtoc: true\r 以打开目录，但是默认是关闭的，可以更改 themes\\pure\\layouts\\partials\\sidebar-toc.html 里第二行为\n\u0026lt;aside collapse: class=\u0026quot;sidebar sidebar-toc collapse in\u0026quot; id=\u0026quot;collapseToc\u0026quot; itemscope itemtype=\u0026quot;http://schema.org/WPSideBar\u0026quot;\u0026gt;\r 就可以默认开启目录\n ✅4月22日更新 这个主题的手机网页支持就离谱，无法显示右侧边栏，目录是以侧边弹出窗口的形式显示的，还是默认关闭比较好\n 开启评论 因为之前用的也是gitalk，所以这次就直接搬过来了。然后就出现了问题：\n查了一下是 repo 这个选项配置错误了，直接写仓库名称\n成功~\n修改版权声明 自带的版权声明下面有个个人简介，其实跟左上角重复了，决定把它关掉。\n找到 themes\\pure\\layouts\\partials\\post\\copyright.html，第14行到第30行都是个人简介，可以直接删掉，不想删掉的话可以更改第14行的 enabled 为 disabled。\n在4-6行添加\n\u0026lt;li\u0026gt;\r\u0026lt;strong\u0026gt;原创内容，转载请注明出处\u0026lt;/strong\u0026gt;\r\u0026lt;/li\u0026gt;\r 修改版权声明\n ✅4月22日更新 如果想要在手机端显示原文链接需要把第7行的 hidden-xs 去掉\n 增加一个留言板 看了一下左侧栏的布置，其实就是一个单独的md文件。似乎作者并没有写增加新目录的功能，但是好在左右两个侧边栏都有目录和标签，造成了重复，这样我们就可以把左侧边栏里的目录和标签去掉，换上留言板，由于留言板的设置与关于一样，这里我就把留言板和关于设置在一起了。\n首先在 config 文件里找到\nmenu:\rmain:\r- identifier: home\rname: Home\rtitle: home\rurl: /\rweight: 1\r...\r 将之后的三、四项删除，将第五项的 title 改成 留言板\u0026amp;关于，weight 改成 3\n并且在 content 目录下创建 about.md 文件，重新渲染网页并点击关于，可以看到md里的内容被改成了html，但是这个时候是没有评论功能的，只能成为一个展示板，没有牌面。\n然后在 content 目录下新建一个文件夹 about，并且把 about.md 文件剪切进去，并且将 config 中的 url 一项改成 about/about，把 params: mainSections 的作用范围改成 [\u0026quot;posts\u0026quot;,\u0026quot;about\u0026quot;] 重新渲染网页就可以看到有评论功能了。\n这样做带来的后果就是可以在目录中归档中看到 about 中的内容，不过可以通过将 about 中的日期提前来尽量减小影响。\n更改上一篇和下一篇的位置 默认的上一篇是指比较新的文章，感觉有丶扯淡，想要换一下\n这里不用修改代码，直接找到语言文件将下一篇和上一篇互换位置就行\n在 themes\\pure\\i18n\\zh.yaml 里将第5行和第7行互换位置\n修改右侧边栏 由于我把左侧边栏的目录和标签选项给删去了，现在没有办法直接进入目录和标签的主页，所以需要修改一下右侧边栏的目录和标签。 找到 themes\\pure\\layouts\\partials\\_widgets\\category.html 和 tag.html，分别将第二行的\n{{ T \u0026quot;widget_categories\u0026quot; }}\r{{ T \u0026quot;widget_tags\u0026quot; }}\r 修改为\n\u0026lt;a href=\u0026quot;{{ \u0026quot;categories\u0026quot; | relLangURL }}\u0026quot;\u0026gt;分类\u0026lt;/a\u0026gt;\r\u0026lt;a href=\u0026quot;{{ \u0026quot;tags\u0026quot; | relLangURL }}\u0026quot;\u0026gt;标签\u0026lt;/a\u0026gt;`\r `\n总结 搭这个博客用了一个晚上，由于第二天课比较多，真正搭完已经是下午了，总的来说还算可以，该有的都有了。\n以后必好好写博客也许\n","id":5,"section":"posts","summary":"写在前面 注意！这篇文章并不是一个教程，只是把我在搭建博客的过程和中间遇到的问题记录一下。 其实之前也搭过一个静态博客，搭了两次，使用hexo框","tags":["blog","hugo","html"],"title":"一个hugo+github pages静态博客是如何搭成的","uri":"https://masterenlu.github.io/blogSite/2020/04/%E4%B8%80%E4%B8%AAhugo-github-page%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%98%AF%E5%A6%82%E4%BD%95%E6%90%AD%E6%88%90%E7%9A%84/","year":"2020"},{"content":"PAT(Basic level)题解 题解已移至CSDN\n","id":6,"section":"posts","summary":"PAT(Basic level)题解 题解已移至CSDN","tags":null,"title":"PAT(Basic level)Practice 题解","uri":"https://masterenlu.github.io/blogSite/2019/03/pat-basic-level-practice-%E9%A2%98%E8%A7%A3/","year":"2019"},{"content":"\n","id":7,"section":"posts","summary":"","tags":null,"title":"Hello Blog","uri":"https://masterenlu.github.io/blogSite/2019/03/hello-world-again/","year":"2019"},{"content":"关于我 一个普通菜鸡计科学生，小秦粉丝\n联系方式 可以在留言板上留言，我在收到留言后会尽快回复。 或者可以选择写邮件给我的邮箱：masterenlu@outlook.com 或者可以在telegram上与我实时聊天（虽然我不经常上tg\n 这是一个留言板 如果想要联系我可以在下方留言，我会尽快回复\n","id":8,"section":"about","summary":"关于我 一个普通菜鸡计科学生，小秦粉丝 联系方式 可以在留言板上留言，我在收到留言后会尽快回复。 或者可以选择写邮件给我的邮箱：masterenlu","tags":null,"title":"About","uri":"https://masterenlu.github.io/blogSite/about/about/","year":"2019"}],"tags":[{"title":"blog","uri":"https://masterenlu.github.io/blogSite/tags/blog/"},{"title":"CNN","uri":"https://masterenlu.github.io/blogSite/tags/cnn/"},{"title":"Fiddler","uri":"https://masterenlu.github.io/blogSite/tags/fiddler/"},{"title":"html","uri":"https://masterenlu.github.io/blogSite/tags/html/"},{"title":"hugo","uri":"https://masterenlu.github.io/blogSite/tags/hugo/"},{"title":"m3u8","uri":"https://masterenlu.github.io/blogSite/tags/m3u8/"},{"title":"outlook","uri":"https://masterenlu.github.io/blogSite/tags/outlook/"},{"title":"PyTorch","uri":"https://masterenlu.github.io/blogSite/tags/pytorch/"},{"title":"ResNet","uri":"https://masterenlu.github.io/blogSite/tags/resnet/"},{"title":"terminal","uri":"https://masterenlu.github.io/blogSite/tags/terminal/"},{"title":"Windows","uri":"https://masterenlu.github.io/blogSite/tags/windows/"},{"title":"Windows-Terminal","uri":"https://masterenlu.github.io/blogSite/tags/windows-terminal/"},{"title":"卷积神经网络","uri":"https://masterenlu.github.io/blogSite/tags/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"title":"图像分类","uri":"https://masterenlu.github.io/blogSite/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"},{"title":"抓包","uri":"https://masterenlu.github.io/blogSite/tags/%E6%8A%93%E5%8C%85/"},{"title":"数学","uri":"https://masterenlu.github.io/blogSite/tags/%E6%95%B0%E5%AD%A6/"},{"title":"最优化导论","uri":"https://masterenlu.github.io/blogSite/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E5%AF%BC%E8%AE%BA/"},{"title":"机器学习","uri":"https://masterenlu.github.io/blogSite/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"title":"注册表","uri":"https://masterenlu.github.io/blogSite/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"title":"邮箱","uri":"https://masterenlu.github.io/blogSite/tags/%E9%82%AE%E7%AE%B1/"},{"title":"钉钉","uri":"https://masterenlu.github.io/blogSite/tags/%E9%92%89%E9%92%89/"}]}